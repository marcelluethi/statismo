/*
 * Copyright 2015 University of Basel, Graphics and Vision Research Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * =====================================================================================
 *
 *       Filename:  MetropolisHastings.h
 *
 *    Description:  Implementation of the Metropolis Hastings Algorithm
 *
 *        Version:  1.0
 *        Created:  13.04.2010 15:58:30
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Sandro Sch√∂nborn (ses), sandro.schoenborn@unibas.ch
 *        Company:  University of Basel
 *
 * =====================================================================================
 */


#ifndef  METROPOLISHASTINGS_INC
#define  METROPOLISHASTINGS_INC

#include "../MarkovChain.h"
#include "../RandomGenerator.h"

namespace sampling
{

  /* \brief Implementation of a Metropolis-Hastings Markov Chain Sampler
   *
   * Proposals are generated by the ProposalGenerator<T> and are evaluated
   * by the DistributionEvaluator<T> -- Attention: Needs LOG Probability values!! */
  template <typename T>
  class MetropolisHastings : public MarkovChain<T>
  {
    public:
      typedef T SampleType;

    public:
      typedef ProposalGenerator<T> Generator;
      typedef DistributionEvaluator<T> Evaluator;
      typedef ChainLogger<T> Logger;

    public:
      /** \brief Init Chain, Use a predefined Generator with seed */
      MetropolisHastings( Generator* propgen, Evaluator* disteval, Logger* chainlogger, const T& initsample, RandomGenerator* engine ) :
        currentSample( initsample ),
        pGenerator( propgen ),
        pEvaluator( disteval ),
        pLogger( chainlogger),
        rndEngine( engine )      {
        currentProbVal = pEvaluator->evalSample( currentSample );
        pLogger->notifyReset( currentSample, currentProbVal, pGenerator, pEvaluator );
        activateDebug();
      }

      virtual ~MetropolisHastings() {}

      virtual void current( SampleType& rSample ) const
      {
        rSample = currentSample;
      }

      virtual double currentValue() const
      {
        return currentProbVal;
      }

      double setState( const SampleType& newState )
      {
        currentSample = newState;
        currentProbVal = pEvaluator->evalSample( currentSample );
        pLogger->notifyReset( currentSample, currentProbVal, pGenerator, pEvaluator );
        return currentProbVal;
      }
      /** Get next sample: in Metropolis-Hastings manner: propose new, accept with
      *   probability P=min(1, P(new)/P(old) * &ans(new->old)/&ans(old->new))
      */
      virtual void next( SampleType& rNextSample )
      {
        // generate a Proposal
        pGenerator->generateProposal( rNextSample, currentSample );

        // Evaluate Proposal
        double probVal = pEvaluator->evalSample( rNextSample );
        double transFW = pGenerator->transitionProbability( currentSample, rNextSample );
        double transBW = pGenerator->transitionProbability( rNextSample, currentSample );

        // transition ratio (cancel two impossible transitions)
        double transitionRatio = transBW - transFW;
        if ( transFW == -std::numeric_limits<double>::infinity() && transBW == -std::numeric_limits<double>::infinity() )
          transitionRatio = 0.0;

        // log Probability acceptance prob
        double acceptVal = std::min<double>( 1.0, std::exp( probVal - currentProbVal + transitionRatio ) );

        if (debug)
        {
          std::cout << "MH: p=" << currentProbVal << ", p'=" << probVal << ", bw=" << transBW << ", fw=" << transFW << ", tratio=" << transitionRatio << ", acceptVal=" << acceptVal << std::endl;
        }

        // Decide whether to accept or reject it
        double rndVal = rndEngine->uniformDbl();
        if ( rndVal <= acceptVal && probVal == probVal && !std::isnan(transitionRatio) )
        {
          //accept
          currentSample = rNextSample;
          currentProbVal = probVal;
          pLogger->notifyAccept( currentSample, currentProbVal, pGenerator, pEvaluator );
        }
        else
        {
          pLogger->notifyReject( rNextSample, probVal, pGenerator, pEvaluator );
          rNextSample = currentSample; // keep current state
          //reject - do nothing
        }
      }

    private:
      void activateDebug()
      {
#ifdef DEBUG
        debug=true;
#else
        debug=false;
#endif
      }

    private:
      SampleType currentSample;
      double currentProbVal;

      Generator* pGenerator;
      Evaluator* pEvaluator;
      Logger* pLogger;

    private:
      RandomGenerator* rndEngine;
      bool debug;
  };
}

#endif   /* ----- #ifndef METROPOLISHASTINGS_INC  ----- */
